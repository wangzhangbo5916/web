# React基础知识

## 常见问题

### 一个文件只导出一个组件好还是一个文件导出多个组件好？

#### 总结

**根据组件的相关性**

- 高相关性：如果多个组件之间高度相关且通常一起使用，可以考虑将它们放在同一个文件中。
- 低相关性：如果组件之间的相关性较低，或者组件较大，建议将它们分开到不同的文件中。

**代码可维护性**

- 单一职责原则：每个文件只包含一个组件，更符合单一职责原则，便于管理和维护。
- 文件大小和复杂度：避免文件过大和过于复杂，保持代码的可读性和可维护性。

**团队规范和项目规模**

- 小型项目：在小型项目中，一个文件导出多个组件可能更方便管理。
- 大型项目：在大型项目中，一个文件导出一个组件更有助于保持代码结构的清晰和一致。

#### 一个文件导出一个组件（推荐）

**优点**

- 清晰的文件结构：每个文件只包含一个组件，文件名与组件名一致，容易查找和理解。
- 模块化：组件的职责单一，便于管理和维护。
- 易于重用：组件可以独立于其他组件进行重用和测试。
- 减少合并冲突：在多人协作时，减少了代码合并冲突的可能性。

**缺点**

- 文件数量多：项目文件数量可能会增加，尤其是在大型项目中。
- 可能导致文件夹层级较深：为了组织文件，可能需要创建更多的文件夹。

```jsx
// components/Button.js
import React from 'react';

const Button = (props) => {
  return <button>{props.label}</button>;
};

export default Button;

// components/Input.js
import React from 'react';

const Input = (props) => {
  return <input type="text" value={props.value} onChange={props.onChange} />;
};

export default Input;
```

#### 一个文件导出多个组件

**优点**

- 减少文件数量：多个相关组件可以放在一个文件中，减少文件数量。
- 方便管理相关组件：相关性很强的小组件可以放在一起，便于管理和维护。

**缺点**

- 文件内容复杂：文件内容可能变得复杂，难以阅读和维护。
- 难以重用：如果组件之间的耦合度高，可能会影响组件的重用性。
- 合并冲突：多人协作时，多个组件在同一个文件中可能会增加合并冲突的风险。

```jsx
// components/FormElements.js
import React from 'react';

export const Button = (props) => {
  return <button>{props.label}</button>;
};

export const Input = (props) => {
  return <input type="text" value={props.value} onChange={props.onChange} />;
};
```

### 函数式组件使用函数声明好还是使用函数表达式？

#### 结论

- 函数声明：语法简洁，支持提升，适用于简单组件和个人偏好。
- 函数表达式：更灵活，支持箭头函数和一致的代码风格，适用于复杂组件和现代 JavaScript 项目。

在 React 项目中，选择使用函数声明还是函数表达式定义函数式组件主要取决于团队的代码风格和一致性要求。无论选择哪种方式，保持代码风格的一致性和可读性是最重要的。

**简单组件 vs. 复杂组件**

- 简单组件：对于简单的展示组件，函数声明和函数表达式都可以使用，选择哪种方式主要取决于个人或团队的偏好。
- 复杂组件：对于包含复杂逻辑和状态管理的组件，函数表达式（特别是箭头函数）可能更灵活和方便。


Airbnb 的 React/JSX 风格指南**推荐使用函数表达式来定义函数式组件**，特别是箭头函数。这有助于保持代码风格的一致性，特别是在现代 JavaScript 项目中。

#### 函数声明（Function Declaration）

```jsx
function MyComponent(props) {
  return <div>Hello, {props.name}!</div>;
}
```

**优点**

- 提升（Hoisting）：函数声明会被提升到作用域的顶部，这意味着你可以在定义之前使用它们。
- 语法简洁：函数声明的语法相对简洁明了，容易理解。

**缺点**

- 一致性问题：如果项目中有大量的函数表达式（例如，箭头函数），使用函数声明可能会导致代码风格不一致。
- 不适合复杂逻辑：在包含复杂逻辑和状态管理的组件中，函数声明可能不如函数表达式灵活。

#### 函数表达式（Function Expression）[推荐]

```jsx
const MyComponent = (props) => {
  return <div>Hello, {props.name}!</div>;
};
```

**优点**

- 一致性：如果你在项目中广泛使用箭头函数和函数表达式，那么使用函数表达式定义组件可以保持代码风格的一致性。
- 简洁的绑定：箭头函数自动绑定 this，虽然在函数式组件中 this 并不常用，但在某些情况下使用箭头函数定义组件可能更简洁。
- 更灵活的定义：函数表达式可以更灵活地定义和使用，比如在条件语句、回调函数和闭包中。

**缺点**

- 没有提升（No Hoisting）：函数表达式不会被提升，因此必须在定义之后才能使用。
- 语法稍复杂：对于新手来说，箭头函数的语法可能不如函数声明直观。


### 为什么子组件不能定义在父组件的内部？

#### 问题场景

子组件直接定义在父组件内部，如下图所示：

```tsx
export default function Gallery() {
  // 🔴 永远不要在组件中定义组件
  function Profile() {
    // ...
  }
  // ...
}
```

通常需要按照下面的定义和使用：

```tsx
export default function Gallery() {
  // ...
}

// ✅ 在顶层声明组件
function Profile() {
  // ...
}
```

#### 回答

将子组件定义在父组件内部虽然在某些情况下是可行的，但通常不推荐这样做。主要原因包括性能问题、代码可读性和维护性，以及组件的重用性。推荐将子组件定义在父组件外部，通常是在单独的文件中。如果确实需要在父组件内部定义子组件，可以考虑使用 useMemo 或 useCallback 来缓存子组件，从而避免不必要的性能开销。

##### 1. 性能问题

**每次渲染都会重新定义子组件**

当你在父组件的函数体内定义子组件时，每次父组件重新渲染时，子组件也会被重新定义。这会导致子组件的重新创建和重新渲染，即使子组件的 props 或 state 没有变化。

```jsx
const ParentComponent = () => {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount(count + 1);
  };

  // 子组件定义在父组件内部
  const ChildComponent = () => {
    console.log('ChildComponent rendered');
    return <div>Child Component</div>;
  };

  return (
    <div>
      <button onClick={handleClick}>Increment</button>
      <ChildComponent />
    </div>
  );
};
```

在这个示例中，每次点击按钮导致 ParentComponent 重新渲染，ChildComponent 也会被重新定义和渲染。即使 ChildComponent 本身没有任何变化，它还是会重新渲染，导致不必要的性能开销。

##### 2. 代码可读性和维护性

**难以阅读和理解**

将子组件定义在父组件内部会增加代码的复杂性和难以阅读。特别是在大型应用中，这种做法会导致代码结构混乱，难以维护。

```jsx
const ParentComponent = () => {
  // 子组件定义在父组件内部
  const ChildComponent = () => {
    return <div>Child Component</div>;
  };

  return (
    <div>
      <ChildComponent />
    </div>
  );
};
```
相比之下，将子组件定义在独立的文件中，可以使代码更加模块化和易读：

```jsx
// ChildComponent.js
const ChildComponent = () => {
  return <div>Child Component</div>;
};

export default ChildComponent;

// ParentComponent.js
import ChildComponent from './ChildComponent';

const ParentComponent = () => {
  return (
    <div>
      <ChildComponent />
    </div>
  );
};

export default ParentComponent;
```

##### 3. 组件的重用性

**难以重用**

将子组件定义在父组件内部会限制子组件的重用性。如果子组件定义在父组件内部，那么它只能在这个父组件中使用，无法在其他地方轻松重用。

```jsx
const ParentComponent = () => {
  // 子组件定义在父组件内部
  const ChildComponent = () => {
    return <div>Child Component</div>;
  };

  return (
    <div>
      <ChildComponent />
    </div>
  );
};
```
相比之下，将子组件定义在独立的文件中，可以轻松在多个父组件中重用：

```jsx
// ChildComponent.js
const ChildComponent = () => {
  return <div>Child Component</div>;
};

export default ChildComponent;

// ParentComponent1.js
import ChildComponent from './ChildComponent';

const ParentComponent1 = () => {
  return (
    <div>
      <ChildComponent />
    </div>
  );
};

export default ParentComponent1;

// ParentComponent2.js
import ChildComponent from './ChildComponent';

const ParentComponent2 = () => {
  return (
    <div>
      <ChildComponent />
    </div>
  );
};

export default ParentComponent2;
```

#### 最佳实践

**将子组件定义在父组件外部**

最简单的解决方案是将子组件定义在父组件的外部，通常是在单独的文件中。这不仅有助于性能优化，还能提高代码的可读性和重用性。

**使用`useMemo`或`useCallback`**

如果确实需要在父组件内部定义子组件，可以考虑使用 useMemo 或 useCallback 来缓存子组件，从而避免每次渲染时重新创建子组件。

```jsx
import React, { useState, useMemo } from 'react';

const ParentComponent = () => {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount(count + 1);
  };

  // 使用 useMemo 缓存子组件
  const ChildComponent = useMemo(() => {
    return () => {
      console.log('ChildComponent rendered');
      return <div>Child Component</div>;
    };
  }, []);

  return (
    <div>
      <button onClick={handleClick}>Increment</button>
      <ChildComponent />
    </div>
  );
};

export default ParentComponent;
```