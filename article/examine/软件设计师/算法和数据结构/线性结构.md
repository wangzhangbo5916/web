# 线性结构

## 字符串的KMP（Knuth-Morris-Pratt）算法

Knuth-Morris-Pratt (KMP)算法是一个用于在文本字符串中查找匹配模式的高效算法。它通过在失败匹配时尽可能少地回溯来实现线性时间复杂度。以下是对KMP算法的详细解释、图解和JavaScript实现。

### KMP算法的基本思想

KMP算法通过预处理模式字符串来构建“部分匹配表”（也称为“next数组”或“前缀函数”），从而在主字符串中查找模式时避免不必要的重新匹配。

### next数组的计算

“next数组”表示模式字符串在每个位置之前的部分字符串中最长的匹配前缀和后缀的长度。计算next数组是KMP算法的关键步骤。

### 计算next数组的步骤

1. **初始化：**
   - 第一个元素 `next[0] = 0`，因为在第一个字符之前没有任何前缀或后缀。
   - 使用两个指针 `i` 和 `j`，初始化 `i = 1`，`j = 0`。

2. **遍历模式字符串，计算next数组：**

   - 如果 `p[i] == p[j]`，则 `next[i] = j + 1`，并且 `i++` 和 `j++`。
   - 如果 `p[i] != p[j]`，且 `j > 0`，将 `j` 更新为 `next[j-1]`。
   - 如果 `p[i] != p[j]`，且 `j == 0`，则 `next[i] = 0` 并且 `i++`。

### 图例

假设模式字符串为 `p = "ABABC"`, 计算它的 `next` 数组：

初始化:
```
p = "ABABC"
next = [0, 0, 0, 0, 0]
```

开始计算:
- `i = 1, j = 0`
    - 扫描：`p[1] != p[0]` => `next[1] = 0`
    - `i++ => 2`

- `i = 2, j = 0`
    - 扫描：`p[2] == p[1]` => `next[2] = j + 1 = 1`
    - 更新 `j++` 和 `i++ => j = 1, i = 3`

- `i = 3, j = 1`
    - 扫描：`p[3] == p[2]` => `next[3] = j + 1 = 2`
    - 更新 `j++` 和 `i++ => j = 2, i = 4`

- `i = 4, j = 2`
    - 扫描：`p[4] != p[3]` 且 `j != 0` => `j = next[1] = 0`
    - 扫描：`p[4] == p[0]` => `next[4] = j + 1 = 1`

最终的 `next` 数组:
```
p = "ABABA"
next = [0, 0, 1, 2, 0]
```

### KMP模式匹配

利用计算好的 `next` 数组，在主字符串中查找模式字符串。

匹配步骤：
1. 初始化：
   - 主字符串 `s` 下标 `i = 0`。
   - 模式字符串 `p` 下标 `j = 0`。

2. 进行匹配：
   - 如果 `s[i] == p[j]`：同时增加 `i` 和 `j`。
   - 如果 `j == m - 1` (模式完全匹配)：返回匹配的起始位置 `i - j`。
   - 如果 `s[i] != p[j]` 且 `j != 0`：将 `j` 更新为 `next[j - 1]`。
   - 如果 `s[i] != p[j]` 且 `j == 0`：增加 `i`。

### 图解例子

假设主字符串：`s = "ABABDABACDABABCABAB"`，模式字符串：`p = "ABABC"`。

1. 初始化:
   ```
   s = "ABABDABACDABABCABAB"
   p = "ABABC"
   next = [0, 0, 1, 2, 0]
   ```

2. 匹配过程:
   - 从 `i = 0` 和 `j = 0` 开始：
     - `s[0] == p[0]` => `i = 1, j = 1`
     - `s[1] == p[1]` => `i = 2, j = 2`
     - `s[2] == p[2]` => `i = 3, j = 3`
     - `s[3] != p[3]` => `j = next[2] = 1`
     - 继续匹配...

重复以上步骤直到找到匹配或者遍历完主字符串。

### JavaScript 实现

```js
function computeNextArray(p) {
    let next = Array(p.length).fill(0);
    let j = 0;
    for (let i = 1; i < p.length; i++) {
        while (j > 0 && p[i] !== p[j]) {
            j = next[j - 1];
        }
        if (p[i] === p[j]) {
            j++;
        }
        next[i] = j;
    }
    return next;
}

function kmpSearch(s, p) {
    let next = computeNextArray(p);
    let j = 0;
    for (let i = 0; i < s.length; i++) {
        while (j > 0 && s[i] !== p[j]) {
            j = next[j - 1];
        }
        if (s[i] === p[j]) {
            j++;
        }
        if (j === p.length) {
            return i - j + 1; // 找到模式，返回开始位置
        }
    }
    return -1; // 没找到
}

// 示例
let s = "ABABDABACDABABCABAB";
let p = "ABABC";
let result = kmpSearch(s, p);
console.log("Pattern found at index:", result);
```

---

