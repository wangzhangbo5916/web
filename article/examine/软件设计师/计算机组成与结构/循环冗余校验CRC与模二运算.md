# 循环冗余校验CRC与模二运算

循环冗余校验（CRC，Cyclic Redundancy Check）是一种常用的数据校验技术，主要用于检测数据传输或存储中的错误。CRC利用模二运算，尤其是二进制多项式的除法。

## 模二运算

模二运算是二进制数的一种特殊运算，主要用于数据编码与错误检测。其核心操作是“加法”和“乘法”，现在我们详细讲解这两种运算的基本原理，并给出几个案例。

### 模二运算的基本原理

1. **模二加法**：
   - 在模二中，加法是通过异或（XOR）运算实现。
   - 规则：相同的位相加为0，不同的位相加为1。
   - 示例：
     - $$ 0 + 0 = 0 $$
     - $$ 0 + 1 = 1 $$
     - $$ 1 + 0 = 1 $$
     - $$ 1 + 1 = 0 $$

2. **模二乘法**：
   - 在模二中，乘法很简单，类似于与（AND）运算。
   - 规则：只有当两个位都是1时，乘积才为1。
   - 示例：
     - $$ 0 \times 0 = 0 $$
     - $$ 0 \times 1 = 0 $$
     - $$ 1 \times 0 = 0 $$
     - $$ 1 \times 1 = 1 $$

### 案例分析

**案例 1**：模二加法

假设我们进行模二加法运算：
- 输入：`1011` 和 `1100`
  
  逐位进行异或运算：
  - $$ 1 \oplus 1 = 0 $$
  - $$ 0 \oplus 1 = 1 $$
  - $$ 1 \oplus 0 = 1 $$
  - $$ 1 \oplus 0 = 1 $$
  
  所以结果为 `0111`。

**案例 2**：模二乘法

假设我们进行模二乘法运算：
- 输入：`101` 和 `110`
  
  逐位进行与运算：
  - $$ 1 \times 1 = 1 $$
  - $$ 0 \times 1 = 0 $$
  - $$ 1 \times 0 = 0 $$
  
  所以结果为 `100`。

**案例 3**：模二除法（CRC计算）

继续用CRC的情况，假设原始数据为 `110101101`，生成多项式为 `1011`。

1. **扩展数据**：
   - 在原始数据后面附加生成多项式位数（3）的0。
   - 扩展后数据：`110101101000`.

2. **模二除法**：
   - 初始被除数 `110101101000`
   - 除数 `1011`
   
   **步骤**：
   - 对齐后进行异或：
     - 被除数： `110101101000`
     - 除数：   `1011`
     -------------------
     - 结果：   `011011101000`

   - 由于结果的最高位为0，向右移动一位：
     - 被除数： `011011101000`
     - 除数：   `1011`
     -------------------
     - 结果：   `001111101000`

   - 由于结果的前两位都是0，向右移动两位：
     - 被除数： `1111101000`
     - 除数：   `1011`
     -------------------
     - 结果：   `0100101000`

   - 由于结果的最高位为0，向右移动一位：
     - 被除数： `100101000`
     - 除数：   `1011`
     -------------------
     - 结果：   `001001000`

   - 由于结果的前两位都是0，向右移动两位：
     - 被除数： `1001000`
     - 除数：   `1011`
     -------------------
     - 结果：   `0010000`

   - 由于结果的前两位都是0，向右移动两位：
     - 被除数： `10000`
     - 除数：   `1011`
     -------------------
     - 结果：   `00110`
  
   - 由于结果的前两位都是0，向右移动两位：
     - 被除数： `110`
     - 除数：   `1011`
     -------------------
     - 结果：   `011`
     
   - 最后的余数是 `011`（具体计算请参照位数和迭代过程).

3. **结果**：
   - 余数即为CRC值。

在CRC运算中，附加0的步骤是为了确保计算的正确性与可靠性。这里详细解释一下附加0的原因以及附加个数的计算方式。

### 附加0的原因

1. **扩展数据**：原始数据在计算CRC时需要在后面附加零，以便能够进行多项式的除法。附加的每一个0相当于添加一个二进制位，使得被除数的位数增加，有利于与生成多项式进行完全的模二运算。

2. **匹配生成多项式的长度**：CRC算法使用的生成多项式（例如 \( G(x) \)）是一个固定长度的多项式，附加的0的数量与生成多项式的位数相同，允许我们进行整个多项式的除法。这保证了在计算CRC时，所有的数据位都得到考虑。

### 附加个数的计算

- **附加0的个数**：附加的0的个数等于生成多项式的位数减去1。理由如下：
  - 例如，如果生成多项式 \( G(x) \) 是一个4位的二进制数，即 \( 1011 \)，那么其对应的多项式是 \( x^3 + x^2 * 0 + x + 1 \)。
  - 根据多项式的最高次项（也就是4位中的最高位），附加的0个数为 \( 4 - 1 = 3 \)。

### 二进制多项式解析

当我们说一个多项式（如来表示的数据）是“4位”时，实际上指的是二进制表示的位数。例如，生成多项式 \( G(x) = 1011 \) 是4位的二进制数，其中每一位对应多项式中的一个系数。

1. **最高次项的表示**：
   - 对于生成多项式 \( G(x) = 1011 \)，其对应的多项式为 \( x^3 + 0 \cdot x^2 + x + 1 \)。这里，虽然在二进制表示中有4个数字，但实际上它表示的次数是从0开始的。
   - 所以，最高次项是 \( x^3 \)，其指数为3，虽然二进制有4位。

2. **位数与指数的关系**：
   - 总位数 = 指数 + 1
   - 因为指数从0开始计数。如果有4位二进制数，指的是包括最高位在内的4位，这里对应的最高指数是3。

### 举例说明

**例子**：
假设原始数据为 `110101`，生成多项式为 `1011`。

1. **生成多项式长度**： 
   - `1011` 是4位，最高次项是3，因此附加的0个数是 \( 4 - 1 = 3 \)。

2. **附加0后的数据**：
   - 原始数据为 `110101`，附加3个0后变为 `110101000`.

**例子**：
假设原始数据为 `110101`，生成多项式为 `0110`。

1. **生成多项式长度**： 
   - `0110` 是4位，最高次项是2，因此附加的0个数是 \( 4 - 1 = 3 \)。

2. **附加0后的数据**：
   - 原始数据为 `110101`，附加3个0后变为 `110101000`.

这样处理后，新的数据 `110101000` 就可以与生成多项式 `1011` 进行模二除法运算，从而计算出CRC值。

通过这种方式，附加0确保了在CRC运算中，数据和生成多项式的位数匹配，从而保证了计算的规范性和正确性。

## 循环冗余校验CRC

1. **多项式表示**：数据被表示为一个二进制多项式，CRC生成的多项式也可以看作是二进制多项式。

2. **模二除法**：CRC的计算过程可以看作是一个二进制多项式的除法，其中的除法是模二运算。模二运算的特点在于：
   - 加法：相同位的异或操作（XOR）。
   - 乘法：相当于移位操作。

3. **步骤**：
   - 在待发送数据后附加一定数量的0（与CRC多项式的位数相同）。
   - 用生成多项式对这个扩展后的数据进行模二除法。
   - 得到的余数就是CRC校验码。
   - 将CRC校验码附加到原数据后一起发送。

### 总结

CRC是一种高效的错误检测工具，利用模二运算的特性，能够快速地检测出数据传输中的错误。通过有效的多项式选择，CRC可以达到很好的错误检测能力。