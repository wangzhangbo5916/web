# 浮点数

## 浮点数的表示法

### 1. **浮点数的组成部分**

浮点数可以表示为：

$$
\text{value} = (-1)^{\text{数符}} \times (1 + \text{尾数}) \times 2^{\text{实际指数}}
$$

### 2. **各个部分的定义**

- **数符（Sign Bit）**：
  - 1 位，用于表示浮点数的正负。
  - 0 表示正数，1 表示负数。

- **阶符（Exponent Sign Bit）**：
  - 1 位，用于表示阶码（指数）的符号。
  - 这在一些浮点数表示中存在，主要是用于标识阶码是正数还是负数。

- **阶码（Exponent）**：
  - 指定浮点数的大小。
  - 在移码表示中，阶码的实际值通过偏移量（bias）来表示。具体形式为：
    $$ 
    \text{实际指数} = \text{阶码} - \text{Bias} 
    $$
  - 移码是一种编码方式，允许表示的指数值包括负值。

- **尾数（Mantissa）或有效数字（Significand）**：
  - 表示浮点数的有效数字部分。
  - 通常使用 "1 + fraction" 形式，隐含的 "1" 是指在正常形式的情况下的整数部分。
  - 尾数可以通过补码表示（如果该格式允许）。
  - **尾数的表示形式**：在浮点数中，尾数常常由一个隐含的 `1` 加上一个分数部分（fraction）组成。比如8位尾数，可以用以下形式表示：
    $$
    1 + \frac{\text{尾数的有效位}}{256}
    $$
    其中：
    - 尾数的有效位范围是从 \(0\) 到 \(255\)（包括最大值）。

### 3. **如何结合使用**

设16位浮点数，其中阶符1位、阶码值6位、数符1位、尾数8位。若阶码用移码表示，尾数用补码表示，则该浮点数能够表示的数值范围是什么？

- **取值计算**：
  - 通过组合所有这些部分，可以计算浮点数的具体值。
  
- **示例**：
  假设我们有一个浮点数的表示如下：
  ```
  1 位数符 | 1 位阶符 | 6 位阶码 | 8 位尾数
  ```

- **解析步骤**：
  1. **读数符**：
      - 确定浮点数的正负。
  
  2. **读阶符**：
      - 可能影响指数的正负性（在某些标准中，留意其存在与否）。

  3. **读阶码**：
      - 使用移码格式，将读到的阶码转换为实际指数（-31 ~ 32）。
  
  4. **读尾数**：
      - 根据尾数的表示（可能是补码），计算有效数字（-128 ~ 127）。
  
  5. **最大和最小值的计算**
      - **最大值**
        当数符为 0，尾数为最大值（补码中，尾数 127 为 `01111111`）:
        - **尾数** 就表示为 \(1 + \frac{127}{256} = 1.49609375\)，
        - **阶码**最大值是 \(32\)（从偏置计算），最终表示为：
        $$
        1 + \frac{127}{256} = \frac{511}{256}= 1 - 2^{-8} = 1 + 0.49609375 = 1.99609375
        $$
        因此，最终最大值为：
        $$
        \text{value}_{\text{max}} = 1.99609375 \times 2^{32} = (1 - 2^{-8}) \times 2^{32}
        $$
      - **最小值**。
        - 在浮点数的标准表示中，尾数被规范化，通常设置为0以表示我们在数轴上的最底部边界。若使用负的尾数，将使得所表示的值更靠近0（绝对值更小），从而偏离真正的最小值。
        - **尾数**为0。
        - **阶符**为 1，表示为负数，实际指数为 -31。
        由于我们在分析浮点数时的格式为：
        $$
        \text{value} = (-1)^{\text{符号}} \times (1 + \text{fraction}) \times 2^{\text{阶码 - 偏置}}
        $$
        在最小值情况下，尾数被考虑为：
        $$
        1 + 0
        $$
        - 所以，我们的最小值可以计算如下：
        $$
        \text{最小值} = (-1)^1 \times (1 + 0) \times 2^{-31} = -2^{-31}
        $$
  
   6. **总结数值范围**
    根据题目提供的信息，推导出数值范围：
    在这个浮点表示中，阶符位1位，阶码6位：
    - **最大数值（阶码）**：通过移码表示，最大值为 \(63\)（即 \(2^6 - 1\)）。这对应于浮点数的实际表示的最大值。
    - **最小数值（阶码）**：最小值实际为 \(-64\)（即 \(-2^6\)），它表示使用补码对负数的表示。
    - 尾数 \(M\) 为含符号的纯小数，采用补码表示：
      - **最大数**：在补码表示下，尾数最大值为 \(1 - 2^{-8}\)（即\(1 - 0.00390625 = 0.99609375\)），表示正数的极限。
      - **最小数**：尾数可以为 \(-1\)（即对于负的情况）。
    - **最小数的计算**
    \[
    N_{\text{min}} = R^{-64} \times (-1) = -2^{-64}
    \]
    但由于这个上下文中的极限是要考虑到浮点数的表示特性，因此应用为 \(-2^{-63}\)。
    - **最大数的计算**
    \[
    N_{\text{max}} = (1 - 2^{-8}) \times 2^{63}
    \]


### 4. **数值范围**

通过以上关系，可以确定浮点数的表示范围和精度：
- 数符影响最终的符号。
- 实际指数决定了浮点数在数轴上的位置。
- 尾数决定了准确的数值。

## 浮点数计算

### 十进制浮点数转化为二进制的过程

将十进制浮点数转换为二进制的过程可以分为几个步骤。我们将分别处理整数部分和小数部分，最后结合它们。以下是详细步骤：

#### 1. 分离整数部分和小数部分

例如，对于十进制浮点数 `5.75`，我们需要分别处理：
- 整数部分：`5`
- 小数部分：`0.75`

#### 2. 转换整数部分为二进制

##### 方法
- 使用除以 2 的方法，直到商为 0。将每一步的余数逆序排列。

##### 示例：
**5 的转换过程:**

```
5 ÷ 2 = 2 余 1
2 ÷ 2 = 1 余 0
1 ÷ 2 = 0 余 1
```

将余数逆序排列，得到二进制表示：`101`。

#### 3. 转换小数部分为二进制

##### 方法
- 使用乘以 2 的方法。每次乘以 2，记录整数部分，直到小数部分为 0 或达到预定的精确度。

##### 示例：
**0.75 的转换过程:**

1. `0.75 × 2 = 1.5` → 整数部分为 `1`
2. `0.5 × 2 = 1.0` → 整数部分为 `1`（结束，因为小数部分为 `0`）

因此，`0.75` 的二进制是 `0.11`。

#### 4. 结合整数部分和小数部分

将得到的整数部分和小数部分结合：
- 整数部分：`101`
- 小数部分：`11`

#### 完整表示
将它们合在一起，得到：
$$
5.75_{10} = 101.11_2
$$

#### 总结
将十进制浮点数转换为二进制的过程如下：
1. 分离整数和小数部分。
2. 转换整数部分为二进制（除以 2 的方法）。
3. 转换小数部分为二进制（乘以 2 的方法）。
4. 将二者结合。

### 浮点数相加计算

在计算机中，浮点数的相加计算遵循浮点数的表示标准（通常是IEEE 754），并涉及一系列步骤。以下是浮点数相加的详细步骤和流程。

#### 1. 浮点数的表示

浮点数由三部分组成：
- **符号位（S）**：1位，表示数的正负（0表示正，1表示负）。
- **指数（E）**：定长的二进制数，通常是8位（单精度）或11位（双精度）。
- **尾数（M）**：有效数字，通常是23位（单精度）或52位（双精度）。

例如，在IEEE 754的单精度格式中，一个浮点数的结构为：
```
| S | E   | M                     |
|---|-----|----------------------|
| 1 | 8   | 23                   |
```

#### 2. 浮点数相加的步骤

##### 1. 对齐指数

- 比较两个浮点数的指数部分。如果两个数的指数不同，需要将较小指数的数进行调整。通过将小的数的尾数右移，使得两个数的指数相同。

##### 2. 尾数计算

- 改变指数后，可以直接相加。对于尾数的计算要考虑到符号位：
  - 如果两个数的符号位相同，直接相加尾数。
  - 如果符号位不同，则进行相减。

##### 3. 结果处理

- **溢出与舍入**：如果相加后的结果超出了浮点数的表示范围，需要进行舍入和归一化。
- **归一化**：确保结果的尾数在有效范围内（通常尾数为1.xxx形式）。

##### 4. 处理最终的结果

- 将舍入后的结果转换为浮点数格式，更新符号位、指数和尾数部分。

#### 示例：浮点数相加

假设我们要计算两个浮点数：\( A = 1.5 \) 和 \( B = 2.75 \)。

1. **表示**:
   - 在IEEE 754格式中：
     - \( A = 1.5 = 0 \ \ \ 01111111 \ \ \ 10000000000000000000000 \)（符号0、指数127、尾数1.1）
     - \( B = 2.75 = 0 \ \ \ 01111111 \ \ \ 01100000000000000000000 \)（符号0、指数127、尾数1.011）

2. **对齐指数**：
   - 两个数的指数均为127，因此不用对齐。

3. **尾数计算**：
   - 尾数相加：
   - 从\( 1.1 \)（1.5的尾数）加上 \( 1.011 \)（2.75的尾数）。
   - 结果为 \( 1.1 + 1.011 = 11.111 \) （二进制，不足以显示位数）。

4. **处理溢出与归一化**：
   - 结果 \( 11.111 \) 超出了范围，需要右移一位并加1到指数：
   - 新结果为 \( 1.1111 \) 和 \( E \) 变为 \( 128 \)（127+1）。

5. **最终结果**：
   - 最终的浮点数格式为 \( 0 \; 10000000 \; 11111000000000000000000 \)，表示4.25。\

#### 什么是归一化

归一化是将数字（特别是在浮点数表示法中）转换为标准格式的一种过程，它确保数字在一定的范围内以一种统一且标准的方式表示。对于 IEEE 754 浮点数，归一化指的是将数字表示为科学记数法的格式，使其满足特定的条件。

##### 归一化的步骤

以下是对归一化过程的详细解释：

1. **分离整数部分和小数部分**：
   - 将十进制数分为整数部分和小数部分。例如，考虑数字 6.75：
     - 整数部分是 6。
     - 小数部分是 0.75。

2. **转换为二进制**：
   - 将整数部分和小数部分分别转换为二进制：
     - `6` 的二进制是 `110`。
     - `0.75` 的二进制是 `0.11`。
   
   因此，6.75 的二进制表示为 `110.11`。

3. **将数字归一化**：
   - 将二进制数转换为科学记数法格式。在 IEEE 754 中，归一化形式要求每个非零数的二进制表示有一个隐含的 `1` 在小数点左边。例如：
   - `110.11` 可以写为：
     $$ 
     1.1011 \times 2^2 
     $$
   - 在这个表示中，`1.1011` 是尾数（或有效数字），而 `2` 是原始指数。

##### 归一化的意义

- **确保唯一性**：归一化使得每个数都有一个唯一的表示。例如，`001.1` 和 `1.1` 在存储时是相同的。归一化标准化了表示法，消除了冗余。
  
- **提高精度**：通过规范化，浮点数表示可以更有效地使用位数，保留更多的有效数字以提高计算精度。

- **适应范围**：归一化有助于最大化能够表示的数的范围，因为存储的指数部分会用来表示更大的或更小的数。

#### 为什么指数是127

偏置处理是 IEEE 754 浮点数表示法中的一个重要概念，它帮助管理和存储浮点数的指数部分。

##### 偏置值的大小

偏置值的大小取决于浮点数的位数：

- **单精度浮点数 (32 位)**:
  - 1 位符号位
  - 8 位指数位
  - 23 位尾数位
  - **偏置值**: 计算为 \(2^{(k-1)} - 1\)，其中 \(k\) 是指数位的位数。在单精度中，\(k = 8\)，因此
    $$
    Bias = 2^{(8-1)} - 1 = 127
    $$

- **双精度浮点数 (64 位)**:
  - 1 位符号位
  - 11 位指数位
  - 52 位尾数位
  - **偏置值**: 同样计算为 \(2^{(k-1)} - 1\)，在双精度中，\(k = 11\)，因此
    $$
    Bias = 2^{(11-1)} - 1 = 1023
    $$

#### 大阶和小阶

- **大阶** (Higher Order)：指的是尾数中较高位的数字，或者说指数较大的数。例如，当进行浮点数相加时，如果一个数的指数较大，它相对影响结果的精度，属于“大阶”。
  
- **小阶** (Lower Order)：指的是尾数中较低位的数字，或者说指数较小的数。它们在相加时对最终结果的影响较小，因此被称为“小阶”。

当进行浮点数相加时，以下步骤会涉及到大阶和小阶的概念：

1. 指数对齐
- 对齐指数：在执行相加之前，**如果两个浮点数的指数不同，小阶的浮点数需要对齐，以匹配大阶的浮点数。为了促使数相加，可能需要右移小阶的尾数，从而丢失一些低位信息**。
2. 尾数相加
- 计算尾数：在尾数相加的过程中，**大阶数的有效位会对结果产生更大的影响，而小阶数的低位可能会因为尾数知名度的限制，没法准确地反映在最终的结果中**。

#### 总结

计算机中的浮点数相加涉及多个步骤，从对齐指数到尾数计算、溢出处理和归一化。这些操作通通常由计算机硬件（如浮点运算单元）自动处理，使得程序员可以更专注于高层次的算法与逻辑。
