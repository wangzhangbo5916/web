# 奇偶校验法

## 水平奇偶校验方法

水平奇偶校验是一种简单的错误检测机制，主要用于在数据传输过程中确保数据的完整性。它通过计算数据位的奇偶性来判断数据是否被篡改或损坏。

### 原理

- **奇偶校验位**：在每一行（即数据字节或字符）数据的末尾附加一个校验位（Parity Bit）。该校验位的值依据该行中1的个数的奇偶性决定：

  - **奇校验**：如果该行中1的个数为偶数，则校验位设置为1；如果为奇数，则设置为0。
  - **偶校验**：如果该行中1的个数为奇数，则校验位设置为1；如果为偶数，则设置为0。

### 为什么奇校验算的是偶数，偶校验算的是奇数

在水平奇偶校验中，奇校验和偶校验的定义确实可能给人造成一些困惑。下面详细解释这两种校验方式的工作原理和原因。

#### 奇校验（Odd Parity）

在奇校验中，目标是确保每一行数据中1的个数为奇数。这是通过计算该行中1的个数来实现的：

- **计算奇数**：如果一行中1的个数为偶数，为了使总数变为奇数，就需要在行的末尾添加一个校验位1。
- **计算偶数**：如果一行中1的个数本身已为奇数，校验位设置为0。

**总结规则**：
- 1的个数为偶数 → 校验位 = 1
- 1的个数为奇数 → 校验位 = 0

#### 偶校验（Even Parity）

在偶校验中，目标是确保每一行数据中1的个数为偶数。同样是通过计算该行中1的个数来实现的：

- **计算奇数**：如果一行中1的个数为奇数，为了使总数变为偶数，就需要在行的末尾添加一个校验位1。
- **计算偶数**：如果一行中1的个数已为偶数，校验位设置为0。

**总结规则**：
- 1的个数为奇数 → 校验位 = 1
- 1的个数为偶数 → 校验位 = 0

#### 为什么会有这种设计？

- **完整性检测**：通过保证每一行数据的奇偶性，可以快速检测到单个比特位的错误。例如，如果在数据传输中有一个比特被误操作，可能会导致奇数个比特状态翻转，从而导致校验不一致。
- **简化的实现**：奇校验和偶校验都是基于简单的异或运算，因此在硬件和软件实现上非常高效。

#### 示例

考虑一行数据 `1011001`:
- **奇校验**：
  - 1的个数：4（偶数）
  - 需要一个校验位1，使其成为5（奇数）。
  - 附加校验位后，结果为 `1011001 | 1`。

- **偶校验**：
  - 1的个数：4（偶数）
  - 校验位为0，不需要更改。
  - 附加校验位后，结果为 `1011001 | 0`。

### 举例说明

假设我们使用奇校验进行数据传输：

#### 示例数据

```
数据行 1: 1011001
数据行 2: 1101000
数据行 3: 0110110
```

#### 计算操作

1. **数据行 1: 1011001**
   - 1的个数 = 4（偶数）
   - 校验位 = 1
   - 结果：`1011001 | 1`

2. **数据行 2: 1101000**
   - 1的个数 = 3（奇数）
   - 校验位 = 0
   - 结果：`1101000 | 0`

3. **数据行 3: 0110110**
   - 1的个数 = 4（偶数）
   - 校验位 = 1
   - 结果：`0110110 | 1`

#### 最终结果

附加校验位后的数据变为：

```
1011001 | 1
1101000 | 0
0110110 | 1
```

假设我们使用偶校验进行数据传输：

#### 示例数据

```
数据行 1: 1011001
数据行 2: 1101000
数据行 3: 0110110
```

#### 计算操作

1. **数据行 1: 1011001**
   - 1的个数 = 4（偶数）
   - 校验位 = 0
   - 结果：`1011001 | 0`

2. **数据行 2: 1101000**
   - 1的个数 = 3（奇数）
   - 校验位 = 0
   - 结果：`1101000 | 1`

3. **数据行 3: 0110110**
   - 1的个数 = 4（偶数）
   - 校验位 = 1
   - 结果：`0110110 | 0`

#### 最终结果

附加校验位后的数据变为：

```
1011001 | 0
1101000 | 1
0110110 | 0
```

### 校验过程

在接收方：
1. 每一行数据与其校验位一起进行检查。
2. 计算接收到的数据中1的个数，结合校验位判断数据的完整性。

- 如果计算的奇偶性与校验位匹配，则数据完整。
- 如果不匹配，则说明数据在传输过程中出现了错误。

### 总结

水平奇偶校验方法简单易用，适合于一些基本的错误检测场景。然而，它只能检测到单个错误（即一个比特位被翻转），对于多个比特位的错误可能无法检测到。因此，在需要更高可靠性的场合，通常会结合其他更复杂的错误检测和纠正方法。

## 垂直奇偶校验法

垂直奇偶校验是一种用于数据传输中检测误差的方法，它通过每一列的奇偶性来进行校验。与水平奇偶校验类似，垂直奇偶校验也可以用于发现数据的损坏，但其工作原理略有不同。

### 原理

垂直奇偶校验的基本步骤如下：

1. **数据矩阵**：将要传输的数据组织成一个矩阵；每一行通常表示一个字节或一个字符。
2. **逐列计算**：对每一列中的数据位进行奇偶性计算，决定是否附加一个校验位。
3. **校验位**：每一列的校验位依据该列中1的个数的奇偶性确定：
   - 如果该列中1的个数为偶数，校验位设置为1（在奇校验中）或0（在偶校验中）。
   - 如果该列中1的个数为奇数，校验位设置为0（在奇校验中）或1（在偶校验中）。

### 举例说明

假设我们使用垂直奇校验对以下数据进行操作：

#### 示例数据

```
数据行：
1. 1011001
2. 1101000
3. 0110110
```

#### 计算操作

将数据构建成一个矩阵，逐列进行奇偶性计算：

```
   1  0  1  1  0  0  1
   1  1  0  1  0  0  0
   0  1  1  0  1  1  0
------------------------
```

- **第一列**：1, 1, 0 → 1的个数 = 2（偶数）→ 校验位 = 0
- **第二列**：0, 1, 1 → 1的个数 = 2（偶数）→ 校验位 = 0
- **第三列**：1, 0, 1 → 1的个数 = 2（偶数）→ 校验位 = 0
- **第四列**：1, 1, 0 → 1的个数 = 2（偶数）→ 校验位 = 0
- **第五列**：0, 0, 1 → 1的个数 = 1（奇数）→ 校验位 = 1
- **第六列**：0, 0, 1 → 1的个数 = 1（奇数）→ 校验位 = 1
- **第七列**：1, 0, 0 → 1的个数 = 1（奇数）→ 校验位 = 1

#### 校验位结果

垂直校验位结果为：`0000111`

#### 最终结果

附加校验位后的数据矩阵将变为：

```
   1  0  1  1  0  0  1
   1  1  0  1  0  0  0
   0  1  1  0  1  1  0
------------------------
   0  0  0  0  1  1  1
```

### 校验过程

在接收方：
1. 对接收到的每一列数据进行相同的奇偶性计算。
2. 将计算得出的校验位与附加的校验位进行比较。

- 如果所有列的计算结果与校验位一致，表示数据完整。
- 如果存在不一致，则表示数据在传输过程中发生了错误。

### 总结

垂直奇偶校验方法能够有效检测数据在传输过程中发生的错误，尤其是能够同时检查多条数据行的完整性。不过，与水平奇偶校验一样，垂直奇偶校验只能检测出奇数个错误，不能检测出偶数个错误。因此，对于需要更高错误检测能力的场合，通常会使用更复杂的错误检测或纠正方法。

### 与水平奇偶校验一样，垂直奇偶校验只能检测出奇数个错误，不能检测出偶数个错误

理解“与水平奇偶校验一样，垂直奇偶校验只能检测出奇数个错误，不能检测出偶数个错误”这句话，需要深入了解奇偶校验的工作原理及其限制。

#### 错误检测能力

- **奇数个错误**：如果数据行中翻转了奇数个比特位，奇偶校验能够检测到这种变化。例如，对于原本1的个数为偶数的行，如果翻转了1个比特位（变为奇数），那么有关的校验位将会出现不匹配，从而被检测出。

- **偶数个错误**：如果数据行中翻转了偶数个比特位，比如0、2、4个比特位，奇偶校验无法检测到这种情况。因为在这种情况下，翻转前后1的个数可能仍然保持奇数或偶数不变。

#### 举例说明

假设我们有一行数据 `1101`，并且使用奇校验。原始数据中1的个数为3（奇数），所以校验位为0。

**情况1：奇数个错误**
- 原数据 `1101`，若翻转一个比特位（如 `1111`），1的个数为4（偶数），校验位将变为1，导致校验失败。

**情况2：偶数个错误**
- 原数据 `1101`，若同时翻转两个比特位（如 `1000`），1的个数为2（偶数），校验位不变，为0，这会导致接收方认为数据是正确的，实际上却是错误的。

#### 总结

因此，无论是水平奇偶校验还是垂直奇偶校验，它们的共同局限在于：
- 只能检测到奇数个错误。
- 偶数个错误可能不会被察觉，因为它们可能导致校验结果与原来一致。

这就是为什么人在设计错误检测机制时，通常会选择更复杂的算法（如CRC等），以提高对于多种错误模式的检测能力。