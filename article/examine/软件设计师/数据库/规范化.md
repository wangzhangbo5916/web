# 关系数据库规范化

## 数据库范式

数据库范式化（Normalization）是一种系统化的数据组织方法，用于减少冗余并确保数据依赖性。以下将详细讲解数据库的几个主要范式，包括它们的定义、特点、示例，并使用图例进行解释。

### 1. 第一范式（1NF）

#### 定义
第一范式要求数据库表的每一个字段不可再分，即字段的值必须是原子的。

#### 要求
- 每一个字段只能包含一个值。
- 表中的每一行和列都是唯一的。

#### 示例与图例

假设有一个学生表：

| ID  | Name  | Courses         |
|-----|-------|-----------------|
| 1   | Alice | Math, Physics   |
| 2   | Bob   | Chemistry       |

该表不符合1NF，因为 `Courses` 字段包含了多个值（Math 和 Physics）。

符合1NF的表：

| ID  | Name  | Course      |
|-----|-------|-------------|
| 1   | Alice | Math        |
| 1   | Alice | Physics     |
| 2   | Bob   | Chemistry   |

在图中可以表示为：

```
  +----+-------+-------------+
  | ID | Name  | Course      |
  +----+-------+-------------+
  | 1  | Alice | Math        |
  | 1  | Alice | Physics     |
  | 2  | Bob   | Chemistry   |
  +----+-------+-------------+
```

每个字段都是原子的，因此符合第一范式。

### 2. 第二范式（2NF）

#### 定义
第二范式在满足第一范式的基础上，还要求消除部分依赖，即非主属性必须完全依赖于整个候选键，而不能依赖于候选键的一部分。

#### 要求
- 满足第一范式。
- 每个非主属性完全依赖于主键，而非其一部分（消除部分依赖）。

#### 示例与图例

假设有一个学生课程表：

| StudentID | CourseID | CourseName |
|-----------|----------|------------|
| 1         | 101      | Math       |
| 1         | 102      | Physics    |
| 2         | 103      | Chemistry  |

该表虽然符合1NF，但存在部分依赖：`CourseName` 依赖于 `CourseID`，而不是 `StudentID, CourseID` 这一组合。

符合2NF的表应拆分为：

##### 学生课程表：

| StudentID | CourseID |
|-----------|----------|
| 1         | 101      |
| 1         | 102      |
| 2         | 103      |

##### 课程表：

| CourseID | CourseName |
|----------|------------|
| 101      | Math       |
| 102      | Physics    |
| 103      | Chemistry  |

在图中可以表示为：

```
+-----------+----------+
| StudentID | CourseID |
+-----------+----------+
| 1         | 101      |
| 1         | 102      |
| 2         | 103      |
+-----------+----------+

+----------+------------+
| CourseID | CourseName |
+----------+------------+
| 101      | Math       |
| 102      | Physics    |
| 103      | Chemistry  |
+----------+------------+
```

### 3. 第三范式（3NF）

#### 定义
第三范式在满足第二范式的基础上，还要求消除传递依赖，即非主属性不能传递依赖于候选键。

#### 要求
- 满足第二范式。
- 非主属性不传递依赖于主键（消除传递依赖）。

#### 示例与图例

假设有一个学生信息表：

| StudentID | CourseID | CourseName | Instructor |
|-----------|----------|------------|------------|
| 1         | 101      | Math       | Dr. Smith  |
| 2         | 102      | Physics    | Dr. Johnson|

该表虽然符合2NF，但存在传递依赖：`Instructor` 依赖于 `CourseID`，而不是直接依赖于 `StudentID`。

符合3NF的表应拆分为：

##### 学生课程表：

| StudentID | CourseID |
|-----------|----------|
| 1         | 101      |
| 2         | 102      |
| 2         | 103      |

##### 课程表：

| CourseID | CourseName | Instructor  |
|----------|------------|-------------|
| 101      | Math       | Dr. Smith   |
| 102      | Physics    | Dr. Johnson |

在图中可以表示为：

```
+-----------+----------+
| StudentID | CourseID |
+-----------+----------+
| 1         | 101      |
| 2         | 102      |
+-----------+----------+

+----------+------------+-------------+
| CourseID | CourseName | Instructor  |
+----------+------------+-------------+
| 101      | Math       | Dr. Smith   |
| 102      | Physics    | Dr. Johnson |
+----------+------------+-------------+
```

### 4. BCNF（Boyce-Codd范式）

#### 定义
BCNF是第三范式的强化版本，要求关系中每个非平凡的函数依赖都是由候选键决定的。

#### 要求
- 满足第三范式。
- 如果 \(X \rightarrow Y\) 是关系中的非平凡函数依赖，那么 \(X\) 必须是候选键。

#### 示例与图例

假设有以下表结构：

| StudentID | CourseID | Instructor  |
|-----------|----------|-------------|
| 1         | 101      | Dr. Smith   |
| 2         | 102      | Dr. Johnson |
| 2         | 103      | Dr. Brown   |

在这种情况下，`Instructor` 依赖于 `CourseID`，按理说`CourseID` 应该是候选键，但并非所有的依赖关系都符合要求。

将其转换为BCNF范式后：

##### 学生课程表：

| StudentID | CourseID |
|-----------|----------|
| 1         | 101      |
| 2         | 102      |
| 2         | 103      |

##### 课程讲师表：

| CourseID | Instructor  |
|----------|-------------|
| 101      | Dr. Smith   |
| 102      | Dr. Johnson |
| 103      | Dr. Brown   |

在图中表示为：

```
+-----------+----------+
| StudentID | CourseID |
+-----------+----------+
| 1         | 101      |
| 2         | 102      |
| 2         | 103      |
+-----------+----------+

+----------+-------------+
| CourseID | Instructor  |
+----------+-------------+
| 101      | Dr. Smith   |
| 102      | Dr. Johnson |
| 103      | Dr. Brown   |
+----------+-------------+
```

### 5. 第四范式（4NF）

#### 定义
第四范式要求消除多值依赖。多值依赖意味着一个属性可以决定一组值，但不同属性之间没有依赖关系。

#### 要求
- 满足BCNF。
- 消除多值依赖。
  
#### 示例与图例

假设一个表包含学生与课程和活动的信息：

| StudentID | Course    | Activity      |
|-----------|-----------|---------------|
| 1         | Math      | Football      |
| 1         | Math      | Basketball    |
| 1         | Physics   | Football      |
| 2         | Chemistry | Drama         |

该表中有两组独立的多值依赖：`StudentID -> Course` 和 `StudentID -> Activity`。

为了符合4NF，需要拆分为两个表：

##### 学生课程表：

| StudentID | Course    |
|-----------|-----------|
| 1         | Math      |
| 1         | Physics   |
| 2         | Chemistry |

##### 学生活动表：

| StudentID | Activity    |
|-----------|-------------|
| 1         | Football    |
| 1         | Basketball  |
| 2         | Drama       |

在图中：

```
+-----------+-----------+
| StudentID | Course    |
+-----------+-----------+
| 1         | Math      |
| 1         | Physics   |
| 2         | Chemistry |
+-----------+-----------+

+-----------+-------------+
| StudentID | Activity    |
+-----------+-------------+
| 1         | Football    |
| 1         | Basketball  |
| 2         | Drama       |
+-----------+-------------+
```

### 6. 第五范式（5NF）

#### 定义
第五范式要求消除连接依赖。这个范式主要应用于复杂的数据库关系设计，以破除不必要的重复数据和依赖。

#### 要求
- 满足第四范式。
- 不包含连接依赖。

#### 示例与图例

假设一个表有以下结构，包括学生、课程与导师：

| StudentID | Course | Instructor  |
|-----------|--------|-------------|
| 1         | Math   | Smith       |
| 1         | Math   | Johnson     |
| 2         | Physics| Johnson     |
| 2         | Chemistry | Smith    |

此表中的信息可以分解为更小的表格，去除不必要的连接依赖：

##### 学生课程表：

| StudentID | Course |
|-----------|--------|
| 1         | Math   |
| 2         | Physics|
| 2         | Chemistry|

##### 课程讲师表：

| Course    | Instructor  |
|-----------|-------------|
| Math      | Smith       |
| Math      | Johnson     |
| Chemistry | Smith       |
| Physics   | Johnson     |

##### 学生讲师表：

| StudentID | Instructor  |
|-----------|-------------|
| 1         | Smith       |
| 1         | Johnson     |
| 2         | Johnson     |
| 2         | Smith       |

在图中：

```
+-----------+----------+
| StudentID | Course   |
+-----------+----------+
| 1         | Math     |
| 2         | Physics  |
| 2         | Chemistry|
+-----------+----------+

+----------+-------------+
| Course   | Instructor  |
+----------+-------------+
| Math     | Smith       |
| Math     | Johnson     |
| Chemistry| Smith       |
| Physics  | Johnson     |
+----------+-------------+

+-----------+-------------+
| StudentID | Instructor  |
+-----------+-------------+
| 1         | Smith       |
| 1         | Johnson     |
| 2         | Johnson     |
| 2         | Smith       |
+-----------+-------------+
```

### 总结

数据库规范化通过多个范式对数据进行系统化的组织，减少冗余并确保数据的一致性和可靠性。在实际应用中，根据具体的需求和性能要求，可以选择适当的范式来设计数据库。

| 范式      | 条件                                                                 |
|-----------|----------------------------------------------------------------------|
| 1NF       | 每个字段都包含单一值，所有字段都是原子的。                            |
| 2NF       | 满足1NF，并且每个非主属性完全依赖于主键。                             |
| 3NF       | 满足2NF，并且不存在传递依赖，即非主属性不依赖于其他非主属性。         |
| BCNF      | 满足3NF，并且所有非平凡函数依赖左部都是候选键。                       |
| 4NF       | 满足BCNF，并且消除多值依赖。                                          |
| 5NF       | 满足4NF，并且消除连接依赖。                                          |

---

## 如何根据关系模式和函数依赖集推导出主键和范式

在关系数据库设计中，确定主键和规范化（范式化）关系模式是非常关键的步骤。通过关系模式和函数依赖集，可以推导出主键，并通过规范化过程应用适当的范式。以下将通过一个具体的例子详细说明如何进行这两个步骤。

### 具体步骤和举例

#### 1. 确定关系模式和函数依赖集

假设我们有一个关系模式 \( R(A, B, C, D, E) \) 和以下函数依赖集 \( F \)：

1. \( A \rightarrow B \)
2. \( C \rightarrow D \)
3. \( AC \rightarrow E \)

#### 2. 找到候选键（Candidate Keys）

要找到候选键，需要确定能够唯一标识关系中的每一元组的最小属性集。候选键最常用的方法是计算闭包（Closure）。

##### 计算步骤：

1. **初始化闭包** \(X^+\)：从每个属性集开始，初始化闭包为属性集本身。
2. **应用函数依赖**：根据给定函数依赖集 \( F \)，逐步扩展闭包。
3. **检查覆盖全部属性**：如果闭包 \(X^+\) 包含所有关系模式的属性，则 \(X\) 是候选键。

#### 闭包计算：

##### 对 {A} 初始化
1. 初始闭包 {A+} = {A}
2. 根据函数依赖 `A → B`，得出 {A, B}
3. 无法再扩展至包含所有属性（即无法覆盖 {C, D, E}）

结论：{A} 不是候选键，无法覆盖所有属性。

##### 对 {C} 初始化
1. 初始闭包 {C+} = {C}
2. 根据 `C → D`，闭包扩展为 {C, D}
3. 无法再扩展至覆盖 {A, B, E}，根据函数 C 无法获得 {A} 及其他属性

结论：{C} 无法覆盖所有属性，不是候选键。

##### 对 {A, B} 初始化
1. 初始 {A, B+} = {A, B}：需求满足闭包扩展
2. 根据 `A → B`，初仅拥有ABA，增益C, D, E无法扩展
3. 函数依赖集未用于Ｃ增加闭包扩展覆盖

结论：{A, B} 也无法覆盖 full property {C, D, E}。

##### 对 {A, C} 初始化
1. 初始闭包 {A, C+} = {A, C}
2. 根据 `A → B` 衍生： Clo {A, B, C}
3. 根据 `C → D` 融合：Clo {A, B, C, D}
4. 根据 `A, C → E`全覆盖：涵盖全部子集全扩展无遗漏(all-inclusive)

最终：{A, C} 满足所有属性、函数依赖，{A, C} 是候选 key。

##### 其他组合
虽然必要组合都经过，但是对其不再赘述直接推理。 通过具体IPC(Incremental Process Checking, 逐次增量校验)确保高效直接结果。

### 3. 范式化过程

#### 第一范式（1NF）
所有关系模式都是符合1NF的，因为每个字段都必须是原子的。

#### 第二范式（2NF）
第二范式要求消除部分依赖，即所有非主属性必须完全依赖于整个候选键。本例关系 \( R(A, B, C, D, E) \) 的主键是 {A, C}，需检查非主属性对部分键的依赖。

分析函数依赖：
- \( A \rightarrow B \) 是对 A 的部分依赖（需拆分）
  
为了规范化，需拆分部分依赖的关系模式：
  - 新关系 \( R_1(A, B) \)
  - 新关系 \( R_2(A, C, D, E) \) 

至此，新关系模式 {R1, R2} 满足第二范式。

#### 第三范式（3NF）
第三范式要求消除传递依赖。检查新关系模式中是否有传递依赖：

- \( C \rightarrow D \)，\( AC \rightarrow E \)

已拆分第二范式后，依然存在传递依赖：
  - 在 \(R2\)，析出：
    - 新关系 \(R_3(C, D)\)
    - 新关系 \(R_4(A, C, E)\)

最终，通过依赖关系拆分，得出符合 第三范式的关系模式：

- \( R1(A, B) \)
- \( R3(C, D) \)
- \( R4(A, C, E) \)

这些新模式关系适当满足 3NF 用图器表示如下：

```
关系表 R1 
+----+----+
| A  | B  |
+----+----+
| .. | .. |
+----+----+
```

```
关系表 R3 
+----+----+
| C  | D  |
+----+----+
| .. | .. |
+----+----+
```

```
关系表 R4 
+----+----+----+
| A  | C  | E  |
+----+----+----+
| .. | .. | .. |
+----+----+----+
```

### 总结
1. **Candidates Key** 方法分析：通过函数依赖集计算确定主键闭包。
2. **Normalization**规范化应用：从1NF到2NF再到3NF消灭冗余，确保数据依赖整洁。

---

